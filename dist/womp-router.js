import{createContext as S,defineWomp as k,lazy as L,useCallback as v,useContext as y,useEffect as N,useMemo as b,useState as B,Suspense as W,html as d}from"womp";const C=(t,e=[],n=null)=>(t.forEach(s=>{if(s instanceof Route.class){const r=s.props,a={...r,parent:n,element:r.element,path:r.path,lazy:r.lazy?L(r.lazy):null,fallback:r.fallback,index:null,children:[]};r.index&&(n.index=a),e.push(a),C(s.childNodes,a.children,a)}}),e),$=(t,e=[],n="")=>{for(const s of t){let r="";if(s.path){const a=n&&!n.endsWith("/")||!n&&!s.path.startsWith("/")?"/":"";r+=n+a+s.path,e.push([r,s])}s.children&&$(s.children,e,r)}return e},w=t=>{const e=Object.keys(t);return e.sort((n,s)=>{const r=t[n],a=t[s],c=Object.keys(r).filter(o=>o!=="segments").length,f=Object.keys(a).filter(o=>o!=="segments").length-c;if(f===0){let o=n.split("/"),m=s.split("/");const h=m.length-o.length;if(h!==0)return h;let R=0,g=0;for(let l=0;l<o.length;l++){const p=o[l],i=m[l];if(p.startsWith(":")||R++,i.startsWith(":")||g++,p.startsWith(":")||i.startsWith(":")||p.startsWith("*")||i.startsWith("*"))break}return g-R}return f}),t[e[0]]},O=(t,e)=>{const n={exact:null,parametric:{},fallbacks:{}},s=e!=="/"&&e.endsWith("/")?e.substring(0,e.length-1):e;for(const c of t){const[u,f]=c,o=u.endsWith("*");if(!o&&u.split("/").length!==s.split("/").length)continue;if(u===s){n.exact=f;break}if(!u.includes(":")&&!u.includes("*"))continue;const m=u.split("/");let h="";const R=[];for(let p=1;p<m.length;p++){const i=m[p];h+="\\/",i.startsWith(":")?(p===m.length-1?h+="(.*)":h+="(.*?)",R.push(i.substring(1))):i==="*"?(h+="(.*)",R.push("segments")):h+=i}const l=new RegExp(h,"g").exec(s);if(l){const p={};for(let i=1;i<l.length;i++)p[R[i-1]]=l[i];o?n.fallbacks[u]=[f,p]:n.parametric[u]=[f,p]}}const r=Object.keys(n.parametric),a=Object.keys(n.fallbacks);return n.exact?[n.exact,{}]:r.length?w(n.parametric):a.length?w(n.fallbacks):[null,null]},j=(t,e)=>e.startsWith("/")?e:t+(t.endsWith("/")?"":"/")+e,z=t=>d`
		<${P.Provider} value=${t}>
			${t.lazy?t.fallback?d`
								<${W} fallback=${t.fallback}>
									<${t.lazy} />
								</${W}>
						  `:d`<${t.lazy} />`:t?.element}
		</${P.Provider}>
	`,x=S({route:null,params:null,currentRoute:null,setNewRoute:null});export function Routes({children:t}){const[e,n]=B(window.location.pathname),s=v((h,R=!0)=>{n(g=>{const l=j(g,h);return R&&g!==l&&(history.pushState({},null,l),r.currentRoute=l),l})}),r={route:null,params:null,currentRoute:e,setNewRoute:s},a=b(()=>C(t.nodes),[]),c=b(()=>$(a),[]);N(()=>{window.addEventListener("popstate",()=>{s(window.location.pathname,!1)})},[]);const[u,f]=O(c,e);if(r.params=f,!u)return d`<div>Not found!</div>`;//! Make custom component. Allow to override it.
let o=u,m=null;for(o.nextRoute=m;o.parent;)m=o,o=o.parent,o.nextRoute=m;return r.route=o,d`<${x.Provider} value=${r}>${z(o)}</${x.Provider}>`}k(Routes,{name:"womp-routes"});const P=S(null);export function Route({route:t}){return d``}k(Route,{name:"womp-route"});export function ChildRoute(){const t=y(x);let e=null;const n=t.route;if(t){const s=n.nextRoute;s?e=s:n.index&&(e=n.index)}return t.route=e,z(e)}k(ChildRoute,{name:"womp-child-route"});export function Link({to:t,children:e}){const n=useNavigate(),s=y(P);let r=t;if(!r.startsWith("/")){let c=s;for(;c;){const u=c.path;if(u){const f=u.endsWith("/")?"":"/";r=c.path+f+r}c=c.parent}}return d`<a href=${r} @click=${c=>{c.preventDefault(),n(r)}}>${e}</a> `}Link.css=" :host { display: inline-block; } ",k(Link,{name:"womp-link"});export const useParams=()=>y(x).params,useNavigate=()=>y(x).setNewRoute;
